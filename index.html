<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="未实践之事，无评价之理。">
<meta property="og:type" content="website">
<meta property="og:title" content="VKYH-2017-8-17">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="VKYH-2017-8-17">
<meta property="og:description" content="未实践之事，无评价之理。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VKYH-2017-8-17">
<meta name="twitter:description" content="未实践之事，无评价之理。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>VKYH-2017-8-17</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">VKYH-2017-8-17</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">未实践之事，无评价之理。</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/12/模型融合方案Stacking原理与实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VKYH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VKYH-2017-8-17">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/12/模型融合方案Stacking原理与实现/" itemprop="url">模型融合方案Stacking原理与实现</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T21:46:03+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>机器学习是基于统计学原理的一门技术。今天，我将给各位献上stacking模型融合方案原理简介与实现。首先，在此介绍几个前置概念。</p>
<p><strong>1.数据K折交叉验证(K-FOLD)</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10738320-88674ef73823aa37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1 数据K折交叉"></p>
<p>如上图所示，我们在获得一个完整数据集后，将数据分为K份（图中设置K为5），每次遍历数据取其中1份作为测试集，其余K-1份作为训练集。同时，对于任意一个基础机器学习模型而言，将会重复K次对数据进行处理的过程，这即为k-fold机制。</p>
<p><strong>2.基模型</strong><br>Stacking中的对数据K折交叉验证处理过程中，用到的机器学习模型。</p>
<p><strong>3.stacking原理</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/10738320-42aecde107ac6f39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 Stacking原理图"></p>
<p>Stacking原理如上图所示。下面我将结合具体数据维度，来对该机制进行说明。<br>假设我得到训练集Train_data，维度为：m<em>n,同时测试集Test_data维度为a</em>（n-1）。同时假设使用Train_data中所有特征进行训练，则从中取出一列label列表，其长度为m，此时Train_data维度变为(m*(n-1))。之后，设置K个机器学习模型作为基模型（本案例中所设置数字为5）。之后，我们分别取这K个模型中，每一个模型进行训练集上K折交叉处理。在一次迭代中，将数据的第K份作为测试集，其他K-1份作为训练集，从而一次迭代生成维度为(m/k,(n-1)/k)的矩阵。将每一次生成的矩阵拼接起来，则对于一个模型而言，完整K次遍历数据后，将生成维度为（m,n-1)的矩阵。则K个模型而言，我们将这些矩阵横向拼接起来，得到最终超特征矩阵new_train，维度为(m,kn-k)。</p>
<p>除此外，对于测试集Test_data而言，我们也在基模型每次遍历测试集并训练出模型时，对测试集进行预测。每个模型每次遍历得到的测试数据集矩阵维度为(a,n-1),则<br>k次遍历后，最终的到的矩阵维度为(a,kn-k).此时为了保证维度统一，我们对该矩阵进行按行求取均值，将其维度变为(a,n-1)。对于K个模型而言，最终经过上述处理过程后，得到新的测试集上的超特征矩阵new_test，其维度为(a,kn-k)。</p>
<p>上述过程即为stacking第一层处理过程。之后第二层处理过程中，我们将new_train作为训练集，将第一层得到的label集合作为标签进行训练，得到最终训练出的模型，从而对new_test进行预测即可。</p>
<p><strong>4.stacking扩展</strong></p>
<p>在kaggle的比赛上，有的团队在经过第一层处理后得到的new_train矩阵基础上，与原始的train_data矩阵进行横向拼接。同时，对new_test也做此处理。从而选取K个机器学习模型，继续对新数据进行K-fold处理。后续操作与上述同理。但一般经过三层即可结束了。</p>
<p><strong>5.stacking代码实践</strong></p>
<p>代码已经上传至git仓库，请<a href="https://github.com/yanhan19940405/Data_machine_learning/blob/master/stacking_class.py" target="_blank" rel="external">点击查看</a></p>
<p>我用此机制跑了跑某比赛，在没有调参的情况下，与第一名指标相差不是很大，还是较为满意的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/10738320-156f4284c27c6078.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3 跑分图"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/21/文本数据挖掘流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VKYH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VKYH-2017-8-17">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/21/文本数据挖掘流程/" itemprop="url">文本数据挖掘流程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-21T11:02:24+08:00">
                2018-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文主要记录文本数据挖掘大致流程，用以梳理该部分结构知识。<br><strong>1.数据获取</strong><br>对于文本数据而言，在公司项目中大部分数据可以通过购买方式获取数据。但常见的方式即为通过网络爬虫获取，详细请参考我后续爬虫技术教程。该种方式获取数据原理是通过程序自动遍历固定网址，将整个页面HTML结构中，不同页面DOM节点文本信息收集整理，然后缓存到本地数据库中。数据集具有结构不唯一，含有HTML标签，特殊符号等不利于训练的数据，需要后期进一步处理。<br><strong>2.数据清洗与数据预处理</strong><br><strong><strong>2.1文本数据清洗</strong></strong><br>在获得的文本数据集，也叫语料库，里面含有许多无关的HTML标签，前端JS代码段，注释，无关特殊符号等增加训练噪声的数据，因此我们需要对数据进行处理，筛选掉这些无关数据项，技术上一般使用python正则表达式处理即可。最后，对于文本数据中的标点符号，可以剔除掉，用空格来代替。<br><strong><strong>2.2结构化数据</strong></strong><br>通过上述步骤处理后，我们就有了训练语料库。但对于文本数据挖掘而言，运用机器学习模型或者深度学习模型来训练的话还远远不够。对于监督学习，无监督学习，半监督学习而言，监督学习在文本数据瓦解运用上来看目前效果较好，也是最合理的方式。因此我们需要对文本进行打标签（label），这对于回归与分类问题而言具有重要意义。最后，我们要将不同网页的文本数据单独保存为一个文档，然后添加这个文档数据的标签，整个数据集就由多个带标签的文档构成，也叫作文档库。于是数据就有了词汇——》文档——》文档库这么一个简单结构，有利于构成训练矩阵。最后对于部分结构数据中存在的NAN数值项，在大文本训练情况下将这类数据删除即可，数据量小的可以用数值0代替。<br><strong><strong>2.3 分词</strong></strong><br>中文分词原因与处理过程请见我另一篇文本主题分类文章，这里不再详述。<br><strong>3.文本挖掘数值特征工程</strong><br>首先，文本数据集内部全是各种str类型的文本分词数据，这类结构无法直接带入到计算机中进行计算。因此我们需要将数据进一步处理成能够让计算机计算，标注的一种矩阵结构。目前做法一般分两种。<br><strong><strong>3.1词袋模型(BOW)</strong></strong><br>此类方式通过忽略分词语义特征与前后顺序，直接将所有分词放在一个统一的文档集合中，统计每一个分词出现的次数，最后得出一个矩阵。矩阵的列代表每一个分词的出现次数，矩阵的行代表文档数量，在这篇文档出现了的分词次数为m，就在那个位置标注为m即可，其他没出现的文档位置直接标注0，这类矩阵即为词频矩阵，其横向维度即为分词数目，长度会很长，因此对于低频词影响没法忽略掉，需要进一步特征筛选。最后，这类矩阵可以直接带入模型中训练。而目前大部分使用的TF-IDF算法效果较好，其引入了逆文档频率IDF，在词频概率TF基础上计算的词频矩阵能更好的契合主题分类模型。<br><strong><strong>3.2词向量模型</strong></strong><br>这种方式通过one-hot编码将分词序列化。举个例子，我有段文本“今天天气好晴朗”经过分词处理后的结构变为“今天”，“天气”，“好”，”晴朗“。那么通过one-hot编码处理后的每一个分词向量即为：<br>“今天”=[1,0,0,0],”天气”=[0,1,0,0],”好”=[0,0,1,0],”晴朗”=[0,0,0,1],最后这个句子（文档）的词向量模型即为[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]].这样不同的文档词向量矩阵组合在一起就构成了一类高维度的文档集合词向量，矩阵的列代表词表大小即为分词个数，行代表文档个数。但考虑到对于分词而言，每一个词向量列元素只有其所在位置标1，而其他位置全部标0，这会造成数据分布不均问题。所以上述简单处理方式外，还有word2vec,doc2vec,fasttext模型进一步优化处理（fasttext,word2vec模型分类过程后续详谈)。有一种基于哈夫曼树的正负训练方式值得关注，其将正负表示词语语序排布问题，在树上正负分别表示左右处理方向，对于语言相似性判断有极大作用。最后，词向量模型高度抽象，无法直接带入统计机器学习模型训练，所以最好与深度学习模型进行嵌入训练，效果最佳。<br><strong><strong>3.3特征选取</strong></strong><br>经过编码处理后的矩阵词库大小依然太大，全部带入模型训练的话，拟合起来可能速度太慢。因此需要选择数据量合适，表征能力强，区分度大，经过编码处理后的分词作为训练数据集的特征。因此具体问题就回到了传统数据挖掘数据特征选取问题，一般采用卡方检验，信息增益，随机森林算法进行特征提取即可。<br><strong>4.训练模型和调参</strong><br>这一步就需要看你选择的模型来操作了，从大体上来讲，模型需要对数据进行拟合，要达到相应精度要求，除了确保数据质量高，特征选取合适外，还需要合理的调参设置。为了增强具体模型预测的泛化性，设置合理的L1,L2正则化项也是需要考虑的。此部分就不展开说了，后续结合实例再谈。<br>最后整个文本数据挖掘流程大致如此了，后续可以在这样处理框架下细化操作即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/19/基于TFIDF-XGBoost文本主题分类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VKYH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VKYH-2017-8-17">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/19/基于TFIDF-XGBoost文本主题分类/" itemprop="url">基于TFIDF+XGBoost文本主题分类</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-19T19:25:30+08:00">
                2018-07-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在丰富的自然语言处理领域中，文本分类是最基本的应用场景，因此使用一套合适的方案对于文本分类上的运用具有积极的效果。本文主要介绍基于词频的TF-IDF的特征提取，加上XGBoost的文本多分类方方案。<br><strong>1.数据预处理</strong><br>首先，文本数据源来自于网络爬取数据，所有标签都通过人工标注的方式产生，具有数据质量不高，结构复杂的问题。其结构为每一行代表一个新闻训练实例，其中context中表示爬去的新闻具体文本内容，tittle表示新闻标题，theme表示每一个新闻训练实例的标签(label)。从中可以看出数据中含有网络爬虫包含的HTML标签，部分数据项为空，包含无关标点符号(比如逗号，顿号，句号等),也包含了数字等等，同时也包含文本主题分类无关的高频词汇（如的，得等）。这些内容增加了利用监督学习训练模型的的噪声干扰。因此对于数据我这里做了基本预处理，引入Python正则表达式库，将HTML标签，文本标点符号，数字内容过滤掉，然后引入中文停词表(可以上网络下载)，也将数据集中的文本在中文文本分词阶段，过滤掉在停词表中的词汇。<br><strong>2.中文文本分词</strong><br>对于自然语言领域而言，中英文数据集有个显著特点，就是中文词汇之间没有明显的分隔符，而英文之间却有自然的空格符来分隔，因此数据需要使用分词工具来将一大段文本分割为不同的单词词汇，用以转为训练矩阵进行主题分类。这里使用的是中文jieba分词工具，将每一段文本处理成分词结构，之后存储于一个txt文件中，分词处理的代码和处理后的数据如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/10738320-5cccca5058eb4b22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/490" alt="图1 分词代码"><br><img src="https://upload-images.jianshu.io/upload_images/10738320-3ab8312a716db8fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="图2 分词处理后的数据格式"><br><strong>3.文本特征提取</strong><br>经过如上步骤的文本数据处理过程之后，我们需要将文本文件转化为数值向量以便于能够带入机器学习分类器进行分类，本文此处使用的是TF-IDF算法进行处理。<br><strong><strong>3.1 TF-IDF算法原理</strong></strong><br>该算法通过统计字词分布频率用以评估一个字词对于一个文本数据集的重要程度。字词的重要性是指如果它在文本中出现的次数越多，那么其所占概率分布相比于其他词汇更高，则表明该词汇对这个文本而言越重要。TF-IDF的算法思想就在于如果一个分词相对于一个文档出现频率（TF)越高,则表示这个分词对于这个文档而言很重要。如果一个文档集合中（多个文档构成的集合），该类分词出现的文档数目越少，则越能将此类文档与其他文档区分开，而表征此类文档出现的状态参数即为IDF（逆文档频率）值大小。最后将二者频率相乘，即可得到文本词频矩阵，我们也就完成了文本向量化过程。<br><strong><strong>3.2TF-IDF算法过程</strong></strong><br>1.计算文本中每一个分词频率（TF）<br><img src="https://upload-images.jianshu.io/upload_images/10738320-2069b690c41cb14b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/549" alt="图3 分词频率计算"><br>2.计算每一个分词的逆文档频率值(IDF)<br><img src="https://upload-images.jianshu.io/upload_images/10738320-68c3df705f7bdad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/674" alt="图4 分词频率计算"><br>3.计算该类分词文本词频的值（TF-IDF），计算公式即为：TF-IDF=TF<em>IDF<br>4.将计算所得所有分词词频值构成一个矩阵<br><strong><strong>3.3IF-TDF算法缺陷</strong></strong><br>基于TF-IDF的方法是通过统计的思想来实现文本数据向数值型数据转化的。在中文文本语义中，一般开头第一二句话表示该文本主题思想。而这类方法有个缺点，即为通过频率分布可能无法得到表示某一类文本中心思想的主题句段，字词的特征，因此在文本情感分类，主题分类方面存在误差，也可以说这也是基于词频的文本处理方案的通病。<br><strong>四．文本分类</strong><br>经过以上步骤处理过的文本数据集就转化为了词频矩阵。这类矩阵维度适中，可以直接带入统计机器学习库进行主题分类处理，本文在之前比赛经验中，决定采取统计机器学习中对于高精度要求具有普适性的XGBoost进行建模应用，以达到分类目的。<br><strong><strong>4.1 XGBoost算法前置理论</strong></strong><br><strong>**</strong>4.1.1 决策树模型与Boosting算法<strong>**</strong><br>决策树作为一类基础的二叉树模型，每一个决策结果只有“是”或者“否”，其简单，易分类的特点使其广泛用于机器学习分类与回归的基础场景，这里一般采用CART生成算法，为了减少过拟合现象，对于生成的树会进行剪枝操作（该部分详细理论请参阅李航《统计学方法》第五章）。<br>Boosting算法，即提升方法，该算法思想通过将不同的弱分类器线性叠加，同时赋予相应权重，以对于数据进行拟合，从而达到相关分类或者回归效果。其通过拟合下面的假设函数（如下图所示）进行建模。其中w为模型基函数（即为弱分类器），W（m）为每一个弱分类器权值。<br><img src="https://upload-images.jianshu.io/upload_images/10738320-1bd133646adc31b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/301" alt="图5 假设函数"><br>一般Boosting算法建模过程如下图所示，来源于李航《统计学方法》：<br><img src="https://upload-images.jianshu.io/upload_images/10738320-850408ef6d011e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/693" alt="图6 boosting建模过程"><br>其思路即为不同弱分类器线性加法，通过添加不同的弱分类器进行训练，得到损失函数最小值后即停止模型计算过程。<br><strong>**</strong>4.1.2 Gradient boosting(GB)算法<strong>**</strong><br>Gradient Boosting是一种Boosting的方法，其代价函数是常见的拟合程度+正则化项结构，损失函数值取得最小值则代表该模型效果最好。它在数据建模过程中，每一次建模会对于通过代入预先设定好的不同弱分类器和弱分类器数目进行建模。其在模型损失函数的梯度下降方向进行探索，在找到沿着梯度方向下降的时候，此时找到了模型损失函数瞬时最小值，会记录参数进行建模。之后其会进一步沿着梯度下降方向进行相同操作，最后当梯度值变化不大或者相等时停止整个过程。除此外GB算法中弱分类器可以更换为任意机器学习基础模型。<br><strong>**</strong>4.1.3 Gradient boosting Decision Tree(GBDT)算法<strong>**</strong><br>顾名思义，该算法即为GB算法与决策树相结合，其将多个决策树模型作为弱分类器，代入到GB算法作为框架拟合数据集的算法模型。其中CART决策树可以用如下假设函数来表示：<br><img src="https://upload-images.jianshu.io/upload_images/10738320-5ea34c3d7606084f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/247" alt="图7 GBDT算法假设函数"><br>其中Rj表示假设空间，γ每次决策树分叉的返回值，I()表示指示函数，在空号中条件成立情况下为1，否则为0.其中的参数J表征树的深度。<br>而GBDT算法流程大致如下图所示：（图片来源于《The Elements of Statistical Learning》一文）<br><img src="https://upload-images.jianshu.io/upload_images/10738320-85553775645f0a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/478" alt="图8 GBDT算法流程"><br>其中可知该算法关键在于通过不断迭代损失函数值，从而不断拟合下面的式子（如下图所示），从而得到最优解。（注意该式子有的材料将其称作残差计算式，但该算法核心还是在于梯度更新最优解）<br><img src="https://upload-images.jianshu.io/upload_images/10738320-e0e2d46222dee3dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/294" alt="图9 损失函数迭代式"><br><strong>**</strong>4.1.4 XGBoost算法<strong>**</strong><br>Xgboost是基于GB算法框架来实现的，其弱学习器除了可以是CART决策树也可以是线性分类器。通过参阅paper<a href="https://arxiv.org/pdf/1603.02754.pdf" target="_blank" rel="external">《XGBoost: A Scalable Tree Boosting System》</a>，其跟CART决策树的GB算法大致有如下区别:<br>(1). 如下图所示，xgboost在损失函数中的拟合程度，加上了正则化项，当学习器为CART决策树时，正则化项fk与树的参数相关。<br><img src="https://upload-images.jianshu.io/upload_images/10738320-adf87085cf8bd4df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/390" alt="图10 XGBoost损失函数"><br>(2).如下面两幅图所示， GB中使用使用损失函数对f(x)的一阶导数计算出梯度最优解，来迭代损失函数从而学习生成f(x)，而XGBoost算法在迭代过程中是将一阶导数和二阶导数结合起来进行f(x)更新从而达到快速优化每次模型训练速度的目的。如下图所示，第t次损失函数更新计算式。<br><img src="https://upload-images.jianshu.io/upload_images/10738320-991097111d4f25ce.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/332" alt="图11 XGBoost损失函数"><br><img src="https://upload-images.jianshu.io/upload_images/10738320-e1f41b2139246ce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/402" alt="图12 XGBoost损失函数泰勒展开"><br>(3). 如下四副图所示，在文中等式4表示XGBoost模型损失函数，其中XGBoost利用5式计算叶节点最优权重值和利用式子6计算叶子节点最优值。CART回归树中寻找树每一层根节点的最佳切分点的衡量标准是最小化均方差，而在XGBoost中的切分点的标准是树的LR和LF集合并集最大化，计算式如式子7所示 ，式子一般用来计算取得最佳切分点位置，式子中参数都在损失函数（式子4）每次取最优解后迭代更新，确定最优切分点位置。<br><img src="https://upload-images.jianshu.io/upload_images/10738320-cd47af1a7190f545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/408" alt="图13 式子4"><br><img src="https://upload-images.jianshu.io/upload_images/10738320-3094421045b44c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/422" alt="图14 式子5"><br><img src="https://upload-images.jianshu.io/upload_images/10738320-e408999a07bb7871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/384" alt="图15 式子6"><br><img src="https://upload-images.jianshu.io/upload_images/10738320-37f6d47ea8b20330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/435" alt="图16 式子7"><br><strong>**</strong>4.1.5XGBoost算法实现<strong>**</strong><br>代码如下图所示，此处基于XGBoost的sklearn入口实现算法应用，其中在数据切分后，先来者5轮交叉验证进行模型参数选择，之后利用选取的参数模型进行建模训练，最终得出相关数据报告即可，这部分关键代码截图如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/10738320-ccd4c0c19e43052d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="图17 算法代码"><br><em>*五．文本主题分类结果</em></em><br>最终我们选取了learning—rate=0.1的模型进行建模，最终结果如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/10738320-392e4a41f943e1a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="图18 数据分析报告"><br>模型精度达到了74%，远远胜过于贝叶斯的63%与logistic模型的69%（这两类模型作者之前跑过作为对比），的确XGBoost方法对于高精度应用场景具有更好的效果。最后在输出模型标签分布图，即可看到具体标签重要程度，可以进行建模的特征选取。如下图所示：<br>（注意：此处作者训练服务器python库matpolib中文乱码，就不再处理，详情请自己添加中文规则进入matpolib源码中设置即可）<br><img src="https://upload-images.jianshu.io/upload_images/10738320-c6753e9cf4d7df86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="图19 特征重要性分布图"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/08/机器学习算法实践之决策树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VKYH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VKYH-2017-8-17">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/08/机器学习算法实践之决策树/" itemprop="url">机器学习算法实践之决策树</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-08T08:17:15+08:00">
                2018-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>决策树是一种基本的分类与回归方法。决策树模型呈现树形结构，在分类问题中，表示基于特征对实例进行分类的过程，它可以认为是if-then规则集合，也可以认为是定义在特征空间与类空间上的条件概率分布，其主要优点是模型具有可读性，分类速度快。在进行数据学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型。预测时对新的数据利用决策树模型进行分类。决策树模型学习过程主要包含三个步骤：特征选择，决策树生成，决策树修剪。我们将在后面逐步探讨这些内容。<br><strong>1.决策树模型理论</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/28/区块链技术体系初步/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VKYH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VKYH-2017-8-17">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/区块链技术体系初步/" itemprop="url">区块链技术体系初步</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T11:01:59+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.背景</strong><br>在传统互联网的TCP/IP协议下，我们进入了信息爆炸时代。在当前情况下，信息快速成型，低成本传输与大量信息共享得到了实现。目前的互联网金融模式是以中心化记账形式来进行等价值货币转移而运行的，比如A在互联网上转账给B，A需要通过网上发送请求给中心化机构承担者，通过在中心机构记账的方式，将信息转化为价值，再由中心机构将等价值的货币转移至B的账户上。这种情况需要政府或者企业利用信用为中心化机构承担者做出保障，但由于传统信息互联网部分个体篡改局部数据情况无法及时发现甚至无法掌握相应情况，因此这种结构依然存在安全性问题。<br> 因此，我们如何实现传统网络传递价值？这就是近几年火起来的新技术——区块链。2008年中本聪在互联网上一个讨论信息加密的邮件组中发表了一篇文章，文章名叫《Bitcoin: A Peer-to-Peer Electronic Cash System》，勾画了比特币系统的基本框架。 2009年他为该系统建立了一个开放源代码项目 (open source project)，正式宣告了比特币的诞生。区块链技术刚开始是为了支持比特币生成与交易而产生的底层技术，其目的是通过建立去中心化的信任，从而不再依托于单个中心结构记账，从而通过P2P网络直接进行价值交换，从而使得实现传统信息交换互联网变为价值交换互联网成了可能。后续这门技术得到了进一步提炼发展，便从比特币中提取出来，成了今天的区块链技术。<br> <strong>2.区块链的初步以及几个名词解释</strong><br> <strong><strong>2.1 什么是信用？</strong></strong><br> 信用，是指依附在人之间、单位之间和商品交易之间形成的一种相互信任的生产关系和社会关系。如果我们用数据m量化描述这个概念，那么当m的值越高，则描述个体的信用程度越大，人们就更容易相信该个体发布的交易与账户信息。目前的中心化交易体系就是如此，国家建立法制的社会信用体系，利用国家公信力与强有力的法律为银行做保证，从而提升市场对于银行的信用程度，通过银行这一中心化的组织来进行经济行为有效监管与控制。然后大型互联网企业则利用自身平台影响力，不断提升自己平台影响力，通过自身理念与遵守相关法律法规增加用户对其信用基础，从而让用户能够安心使用平台所提供的网络价值交换服务。<br> <strong><strong>2.2 什么是价值转移？</strong></strong><br> 价值转移，是指具有同等购买力的货币进行流通。在当前金融体系下，价值转移行为需要由第三方进行价值记账，价值交换等行为的操作，控制，才能实现价值在不同个体间的转移。<br> <strong><strong>2.3 什么是P2P网络？</strong></strong><br>P2P网络，即对等网络（Peer-to-peer networking），网络参与者共享他们自己的硬件资源（处理能力，存储容量，网络连接，打印机等）的一部分，通过网络提供服务和内容，并且可以由其他对等方直接访问而无需中间实体。 该网络的参与者既是资源，服务和内容提供者（服务器），也是资源，服务和内容获取者。在P2P网络环境中，多台彼此连接的计算机处于相同的位置。 一台电脑可以作为服务器并为网络设置共享资源使用其他计算机，也可作为工作站，网络一般不依赖于专用的集中式服务器，也没有专门的工作站。 网络中的每台计算机既用作对网络服务的请求，也用于响应其他计算机提供资源，服务和内容的请求。<br> <strong><strong>2.4 区块链的定义</strong></strong><br> 区块链技术是指一种去中心化的分布式共享记账存储技术，本质上是数据库技术，是一连串使用密码学方法产生相关联的数据块，每一个数据块即为区块，其包含了一段时间内全网交易信息和用于验证其有效性的信息，每一个区块通过指针连接，上一个区块可以创建下一个区块，整体呈现链式排布。<br>如下图所示，即为传统中心化交易体系，这类体系下中心企业信用度指数要高，同时对于现有以信息传递的互联网体系下，无法实现在线价值转移必须经过第三方平台转移之后才能实现此功能。<br><img src="http://upload-images.jianshu.io/upload_images/10738320-3a28b8f7e0b649bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1 中心化交易体系"></p>
<p>这类体系存在如下问题：1.黑客可以修改转账信息，更改数据后，如果无有效交易检验方法，则在现有的信息网络情况下，这种情况不容易被发现，然后矫正。2.中心化体系下，必须对于中心单位给予强有力的信用保证，但对于网上支付平台下，大部分企业自监自查，一旦中心单位出现数据丢失等不可控困难，这种情况存在很大经济波动风险。3.传统交易体系下，网上支付无法直接在线进行价值交换，使用不是很方便。为了解决上述问题，区块链技术便横空出世了。<br><strong><strong>2.5 区块链系统交易过程</strong></strong><br>如下图所示，在区块链技术体系下，一个区块链系统有很多节点构成，每一个参与的节点都能够记账，即更新数据库信息。区块一利用私钥签名创建交易后，将信息发往全网进行广播，其交易记录通过P2P网络向后传播，然后经过系统共识机制对交易进行验证，确定交易信息有效性后，将验证结果与上一个节点交易记录一起再次利用P2P网络传递给下去，最后各个记账节点依托于验证结果将交易记录写入账本，更新区块存储信息，从而实现了去中心化的分布式记账。<br>而共识机制是用来确定分布式系统节点中的账本记录节点的一种机制，其中目前最常用的是工作量证明机制——各个节点通过区块接入系统，通过本地计算能力高低来确认记账与否的能力。计算能力越高的节点，则越能成为账本记录节点，就能将自己节点的交易信息形成一个新的区块加入链中。一旦加入链中，如果想要修改一个区块链中某个区块交易信息，就必须完成该区块与后一个区块的工作量，从而让更改数据成为不可能。<br><img src="http://upload-images.jianshu.io/upload_images/10738320-2614154946b819f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2 区块链交易过程"><br>鉴于此，实现区块链技术的关键因素也就出来了，即:1.由于每个节点可以自由加入或退出系统，则形成有效的盘P2P动态网络是关键因素。2.形成时间有序排列的切不可更改的系统主体交易账本（由于个体交易账本篡改不会影响后续节点，真实交易记录会在多个节点存在，因此更改局部节点交易账本一般不会对整体系统产生作用）。3.系统含有有效的统一采用的共识机制模型。<br><strong>3.区块链技术理论详解</strong><br><strong><strong>3.1 区块与区块链结构</strong></strong><br><img src="http://upload-images.jianshu.io/upload_images/10738320-9f17b969edf2869b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3 区块结构"><br>区块结构如上图所示，每一个区块包含前一个区块ID，交易记录信息，本区块ID等信息。其中交易记录也被称作账本，其结构有两种，一种是采用链式Hash结构防篡改，一串数据hash区块组成链，每个区块账本包含了最近交易集合的hash值，一旦某个部分数据更改，那么hash校验就会出现许多新的结果，从而实现欺骗行为的甄别。另一种是采用公钥密码机制标识的资产所有者，从而利用公钥做为标识，仅仅只有相应私钥的用户才能拥有转移价值行为操作基础。<br><img src="http://upload-images.jianshu.io/upload_images/10738320-74c585d2ac9aadc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4 区块链结构"><br>如上图所示，区块链是由多个区块连接起来的一种链式结构，区块链之间彼此用指针相互对应关联起来，如图3.1-2，由于每一个区块都可以创建一个新的区块，故需要一种共识机制，也是目前应用最广泛的工作量证明机制，通过比拼不同区块也就是节点的计算能力，算力越高，则就越能获得合法的记账权，从而挂载入区块链，同时产生下一个区块。算力不高的区块就无法挂载入链中，其原理类似于大自然中动物群体生殖权争夺。而新区块的ID不一定是前一个区块加1，此处仅仅作为合理性展示才如此画图。除此外，链越长，信用指数越高，越容易受到人们认可，除此外区块链采用高冗余度的存储系统来进行数据存储，在运用工作量证明机制后，也带来高能耗等缺点，此处我们后面再谈。<br><strong><strong>3.2 区块链的模型架构</strong></strong><br>首先提两个概念，公有区块链与私有区块链。公有区块链是指全世界任何人都有权限，可随时随地读取的、任何人都能发送交易且交易能获得有效确认的、任何人都能参与其中共识过程的区块链，对用户访问区块链系统不做权限限制的区块链，链越长信用度就越高，这也是公有链越能获得大多数人认可的重要原因。而私有区块链通过严格的权限限制供特定人访问运行，安全度得不到保障。<br>如下图所示，区块链模型结构类似于TCP/IP模型结构一样，由图中所示六层组成，从技术最底层向上排列分别是数据层、网络层、共识层、激励层、合约层、应用层。其中数据层，封装了底层数据区块的链式结构和相关的非对称数据加密技术和时间戳等技术；网络层，包含了分布式组网机制数据传播和验证机制，对于交易过程控制意义重大；共识层封装网络节点的共识机制算法模型，对于确立记账节点有重大作用；激励层则包含经济发行机制与分配机制，用于激励遵守规则参与记账的节点，惩罚违反规则的节点；合约层则封装各类算法，编程协议，这给了区块链技术编程基础；应用层则为各类区块链应用程序提供了运行环境。其中图中红色三层为区块链必须的层数，其他三层为非必需层数。<br><img src="http://upload-images.jianshu.io/upload_images/10738320-2d2455b54bad9a66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5 区块链模型结构"><br>除此外，在私有链中，一般不含有激励层，可能由私有链使用者添加强制性因素进行记账节点分配。<br><strong><strong>3.3 区块链的共识机制模型</strong></strong><br>共识机制是区块链技术的核心，其主要起到了交易账本信息验证和确认的作用，同时其决定了哪个区块节点为共识记账节点。同时在拼接区块链时，在上一个区块具体挂载下一个区块时的，所需区块节点也由工作量证明机制来决定的。此处介绍两个运用广泛的共识算法模型。<br><strong>**</strong>3.3.1 工作量证明机制(POW)<strong>**</strong><br>如2.5节的图中所示，在一个稳定的，多个节点达成统一共识机制的系统中，其中一个节点作为证明者，提交已知的，难以计算但容易验证的结果，其他任何节点都能通过验证这个结果确信证明者为了求得结果已经大量完成了相应工作量的计算结果，这就是工作量证明机制。比如飞行员有了10000小时飞行时间，则我们都可以相信这个飞行员有高超的驾驶技术，工作量机制与之同理。工作量证明机制中，其利用SHA256 hash算法计算工作量。一个符合要求的区块hash值由n个前导邻，前导邻个数取决于网络的复杂度。要得到合理的区块hash需要大量的运算，运算速度取决于机器hash运算速度。一个节点拥有合理hash值是一个概率性事件，因此当节点拥有合理hash值时，需要运用大量资源进行计算，完成了相当的工作量，因此算力值越高的节点就越能成为记账节点，这也是挖矿时严重耗电的重要因素。<br>获得记账权概率为算力占总节点算力值的概率值，这也为POW系统的安全提供了很高的保障，毕竟要想攻破一个基于POW的区块链系统，没有一定的算力资源可没法攻破这个系统。<br><strong>**</strong>3.3.2 权益证明机制(POS)<strong>**</strong><br> 这是一个shy256算法替代品，避免大量计算工作量的算法模型。其通过对每一笔的交易销毁的币/天数，来实现证明者对某些数量的钱展示所有权。币天数代表一个特定的币，作为网络中权益代表量化单位，一旦有交易发生币天数就会被销毁且无法重复使用。在给定时间点内，存在有限币/天数是有限的，鉴于此在区块链中，持有更多数据货币的人就会有更多币天数，则类似于股份权益，占比更多的人分红更多。<br> POS安全性将不再靠工作量来保护，而是通过链的一体性来决定的其安全性的，即凡是处于POS中的人区别只是收益不同，但大家都有收益的前提是系统安全性，因此其中大股东更加注重链的安全性与完整性。<br><strong><strong>3.3 区块链的类型</strong></strong><br><strong>**</strong>3.3.1 公有链与私有链<strong>**</strong><br> 具体阐述请见3.2区块链模型架构。此处谈一谈公有链与私有链区别，公有链一般含有一个完整的代币系统，在激励层能够奖励遵守规则的记账节点，惩罚违反规则的记账节点，而私有链中节点是某个组织内部节点，注入权限就不会含有代币系统。公有链就类似于互联网，私有链就类似于局域网，当前大部分公司都在采用私有链技术。<br><strong>**</strong>3.3.2 联盟链<strong>**</strong><br>  其共识过程受到选择预先节点选择控制的区块链，在系统建立前就预先决定记账节点分布与其他节点状态。<br><strong>**</strong>3.3.3 许可链<strong>**</strong><br> 是指每个节点加入区块链需要取得许可的一种区块链种类。<br><strong>**</strong>3.3.4 混合链和复杂链<strong>**</strong><br>伴随着区块链技术发展，链中每个节点可以根据不同需要通过权限控制其功能，比如在同一个系统中，有的节点记账，有的节点可以查询整个链信息，有的节点只能查询部分信息，从而构成了一个复杂但高效的区块链网络。<br><strong>4.总论</strong><br>区块链初步理论体系记录到此结束了，但智能合约部分暂未记录，还在研究，在后续会进行更新完成。从目前收集资料上来看，区块链技术的确有对互联网进行变革的潜力，其价值转移互联网一旦成型，将会对目前的信息网络带来更多积极的影响，值得关注。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/27/机器学习算法实践之感知机模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VKYH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VKYH-2017-8-17">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/27/机器学习算法实践之感知机模型/" itemprop="url">机器学习算法实践之感知机模型</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-27T08:17:40+08:00">
                2018-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇文章作为算法实践系列第三篇，将着重理清楚线性分类模型——感知机。<br><strong>1.感知机理论</strong><br>感知机模型主要是解决二类分类问题的线性分类模型，其分为原始形式与对偶形式。其输入为实例的特征向量，输出为实例的类别（分为正实例和负实例，取值分别为+1和-1）。在几何意义上，感知机将输入的实例划分为正负两类的分离超平面，为此，导入基于误分类的损失函数，利用梯度下降法对损失函数进行极小化操作，从而求得感知机模型。<br><strong>(待后续更新！)</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/23/机器学习算法实践之贝叶斯算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VKYH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VKYH-2017-8-17">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/机器学习算法实践之贝叶斯算法/" itemprop="url">机器学习算法实践之贝叶斯算法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-23T08:32:56+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文作为算法实践系列第二篇，将重点讲解朴素贝叶斯算法与贝叶斯算法理论与应用。<br><strong>1.朴素贝叶斯算法理论</strong><br>朴素贝叶斯算法是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练数据集合，首先基于特征条件独立假设学习输入/输出的联合概率分布，然后基于此模型，对于给定的输入的X，利用贝叶斯定理求出后验概率最大的输出的Y值，即为输入实例所属的分类。<br>此处假设输入空间X为n维向量的集合，输出空间为数据分类标记集合Y={c1,c2,c3….,ck},x是定义在X上的随机向量，y是定义在Y上的随机向量，p(x,y)是x和y的联合概率分布，训练数据集T={(x1,y1),(x2,y2),…,(xN,yN)}是由P(x,y)独立同分布产生的。在上述条件下，朴素贝叶斯法通过训练数据集，先学习先验概率分布p(Y=ck),k=1,2….K,之后在学习条件概率分布P(X=x|Y=ck)=P(X(1)=x(1),…,X(n)=x(n)|Y=ck),k=1,2,….,K(注意:此处(n)是指输入空间的第n个特征向量，也可以理解为上标序号)。最后学习得出两者参数值后，在运用贝叶斯定理，对给定的输入实例x=(x(1),x(2),x(3),…x(n))^T的后验概率P(Y=ck)<em>P(X(n)=x(n)|Y=ck)</em>P(X(n-1)=x(n-1)|Y=ck)…<em>P(X(1)=x(1)|Y=ck)计算比较,最终后验概率最大值所在的Y=ck值，即为该输入实例所属分类情况。<br>其中，对于后验概率最大化即为所属输入实例的分类情况，其含义即为满足了期望风险最小化准则，即以此准则推导出的函数式f(x)=arg max(P(ck|X=x))就是朴素贝叶斯法所采用的原理。此处只是略微提一下原理，请勿和判别模型f(X)决策函数搞混，贝叶斯分类方法与朴素贝叶斯都属于生成模型，由数据驱动学习概率分布得出分类结论，没有决策函数f(x).<br><strong>2.朴素贝叶斯算法实践步奏</strong><br><strong><strong>2.1 前置理论——极大似然估计</strong></strong><br>朴素贝叶斯法中，学习表示通过数据出发估计先验概率P(Y=ck)和条件概率P(X(n)=x(n)|Y=ck)，一般通过极大似然估计法估计相应概率。首先，先验概率P(Y=ck)的极大似然估计计算式如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/10738320-3dd33acbced569c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/460" alt="图1 先验概率计算式"><br>其中I为指示函数，满足条件值为1否则为0。之后，在设第j个特征向量x(j)可能取值的集合为{a[j,1],a[j,2],a[j,3],……,a[j,S]},条件概率p(X(j)=a[i,j]|Y=cK)的极大似然估计计算式即为:<br><img src="https://upload-images.jianshu.io/upload_images/10738320-8e5546130fe55e70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/618" alt="图2 条件概率计算式"><br>其中j=1,2,…,n;l=1,2,…,s;k=1,2,….,K,式中x(i)(j)是指第i个样本的第j个特征，a[j,l]是指第j个特征可能取第l个值。<br><strong><em>*2.2 算法实践步奏</em></strong></em></p>
<blockquote>
<ul>
<li>对数据进行预处理</li>
<li>计算数据集中每个特征向量的先验概率和条件概率</li>
<li>对于给定的实例x=(x(1),x(2),x(3),…x(n))^T,计算后验概率P(Y=ck)<em>P(X(n)=x(n)|Y=ck)</em>P(X(n-1)=x(n-1)|Y=ck)…*P(X(1)=x(1)|Y=ck)的值</li>
<li>得到最后根据后验概率大小得到输入实例预测的分类结果。</li>
</ul>
</blockquote>
<p><strong>3.朴素贝叶斯算法实践</strong><br>具体代码我已上传至Git仓库，详情请<a href="https://github.com/yanhan19940405/MachineLearning-algorithm/tree/master/Bayes%20algorithm" target="_blank" rel="external">点击查看</a>，<br>数据为模拟分类数据，所用python为3.5版本，执行结果如图所示:<br><img src="https://upload-images.jianshu.io/upload_images/10738320-361cf7fbb64a932b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="图3 代码实践执行结果"><br><strong>4.贝叶斯估计理论</strong><br>在用朴素贝叶斯算法进行数据分类处理时，可能会遇到所要估计的概率值为0的情况。这种情况是会影响到具体的后验概率计算结果，使得分类产生偏差，鉴于此，使用贝叶斯估计方法就可以避免上述问题。其中，贝叶斯估计执行逻辑与朴素贝叶斯一样，唯一的区别在于先验概率和条件概率计算式不同。<br>其中，先验概率的贝叶斯估计为:<br><img src="https://upload-images.jianshu.io/upload_images/10738320-c8a9567586a31db7.png?imageMogr2/auto-orient/" alt="图3 贝叶斯估计先验概率"><br>条件概率的贝叶斯估计为：<br><img src="https://upload-images.jianshu.io/upload_images/10738320-e8a7a6e391a479a6.png?imageMogr2/auto-orient/" alt="图4 贝叶斯估计条件概率"><br>在上述式子中，λ≥0，等价于在随机变量各个取值的频数上加上一个正数λ&gt;0。当λ=0时为极大似然估计。在常用的数据分类器中，取λ=1称为拉普拉斯平滑（Laplace smoothing）。最终该算法学习过程与朴素贝叶斯学习过程一样，就不在对其代码进行扩展，整个贝叶斯相关的算法基础模型也就到这里结束了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/22/MachineLearning KNN algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VKYH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VKYH-2017-8-17">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/22/MachineLearning KNN algorithm/" itemprop="url">机器学习算法实践之KNN算法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-22T08:57:28+08:00">
                2018-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.KNN算法前置概念</strong><br>在进行算法基本描述前，先介绍两个概念。对于数据分类算法中，一般性应用场景即为监督学习。监督学习方法分为生成方法和判别方法，最终所得到的模型即为生成模型和判别模型。生成方法由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测模型。该模型特点在于表现了给定输入X产生输出Y的生成关系，是基于数据出发所触发的模型学习过程，其可以还原出联合概率分布P(X,Y)，判别方法不能。除此外，生成方法学习收敛速度更快，当样本容量增加的时候，学到的模型可以更快的收敛于真实模型。典型的生成模型有：朴素贝叶斯法和隐马尔可夫模型。<br>判别方法是由数据直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型，此处待引入训练数据后，由具体训练数据集得出函数模型后，带入具体测试数据集的得出具体数据分类结论即可。判别方法直接面对预测，学习准确率更高。此处需要注意的是，在存在数据特征预处理不完善或者其他无法量化所有特征参数情况下，一旦存在隐变量，判别方法则无法使用，但可以使用生成方法。判别模型有K近邻法，感知机，决策树，logistic回归模型等。<br><strong>2.KNN算法基础理论描述</strong><br>KNN算法，即为K近邻算法，其最简单的描述即为:给定一个训练数据集，将其分好类之后，对于新输入的实例，在训练数据集中找到与该实例最邻近的K个示例，这K个示例多数属于某一类，就将该输入实例分为这一类。鉴于此，我们讨论下算法核心思想，距离度量。<br><strong><strong>2.1KNN算法距离度量</strong></strong><br>在训练数据集给定的情况下，找到具体数据每一项特征向量，将其结合在一起构成一个特征向量集合，即为特征空间。在使用欧式距离公式（公式如下图所示）:<img src="http://img.blog.csdn.net/20161123194009176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="图1:欧式距离"><br>运用特征空间里的参数将其实例之间的欧式距离计算出来，结果数值越小则两个实例点几何距离越近，分类结果越相似。<br><strong><strong>2.2 K值选择</strong></strong><br>k值的选择也要在偏差与方差之间取得平衡。若k取很小，例如k=1，则分类结果容易因为近似误差减小而出现错误，导致只有与输入实例相近的训练实例才会有分类效果，其他实例则无法准确分类，容易发生过拟合现象；若k取很大，例如k=N(N为训练集的样本数），则对所有测试样本而言，其利用较大领域范围中的训练实例进行预测。与输入实例较远的训练实例也会对预测产生作用，使得近似误差增大，使得预测产生错误。利用交叉验证（Cross Validation）评估一系列不同的k值，选取结果最好的k值作为训练参数。此文中数据情况简单，K值就取的是5即可达成需要。<br><strong><strong>2.3 分类决策规则</strong></strong><br>算法中的分类决策规则为多数表决，即由输入实例的K个近邻的实例中的多数类来决定该输入实例所属分类情况。<br><strong>3.KNN算法分类步骤</strong></p>
<blockquote>
<ul>
<li>对数据进行预处理，多个特征参数的数据要进行归一化处理</li>
<li>求输入实例与训练样本之间的相似性</li>
<li>依据欧式距离数值从小到大排序</li>
<li>选择前K个最为相似的数据中，得到多数相同分类样本对应的类别</li>
<li>得到输入实例预测的分类结果。</li>
</ul>
</blockquote>
<p><strong>4.KNN算法实践</strong><br>具体代码我已上传至Git仓库，详情请<a href="https://github.com/yanhan19940405/MachineLearning-algorithm/tree/master/KNN" target="_blank" rel="external">点击查看</a>，数据来源于kaggle上某约会网站训练数据，具体仓库中有，最终数据可视化展示结果如下图所示:<br><img src="https://upload-images.jianshu.io/upload_images/10738320-688087e644ba4143.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="图2 数据分类结果图"><br>图中横轴是训练数据集分类，Y轴是训练数据与输入实例欧式距离，红色即为与实例相近的实例分类情况。<br>到此，此算法大致就结束了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/18/Resources/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VKYH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VKYH-2017-8-17">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/18/Resources/" itemprop="url">WY's FE Resources</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-18T20:47:42+08:00">
                2018-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>基于Node.js的开发技术</strong><br>1.<a href="https://github.com" target="_blank" rel="external">Github</a>;<br>2.<a href="https://cn.vuejs.org/" target="_blank" rel="external">VUE.JS</a>;<br>3.<a href="https://www.vue-js.com/" target="_blank" rel="external">vue.js论坛</a>;<br>4.<a href="https://www.iviewui.com/" target="_blank" rel="external">iview2.0 UI库</a>，这是vue,js专有UI库;<br>5.<a href="https://segmentfault.com/" target="_blank" rel="external">segmentfault</a>,IT技术讨论社区;<br>6.<a href="http://huziketang.com/books/react/" target="_blank" rel="external">react小书</a>,react技术入门必备;<br>7.<a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="external">Webpack很好地总结资料</a>，搭建脚手架基础的资料;<br>8.<a href="https://doc.webpack-china.org/" target="_blank" rel="external">Webpack中文文档</a>，很好地文档资料;<br>9.<a href="https://segmentfault.com/a/1190000007019545" target="_blank" rel="external">Fetch交互方式</a>，基于promise前后端异步交互方法;<br>10.<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="external">Axios中文文档</a>，前后端交互方式文档，与fetch不一样;<br>11.<a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="external">Ant Design</a>，这是react技术广泛使用的UI库;<br>12.<a href="https://motion.ant.design/" target="_blank" rel="external">Ant Motion</a>，这是基于react的动画解决方案;<br>13.<a href="http://www.expressjs.com.cn/" target="_blank" rel="external">Express</a>，基于node.js的前端调试服务器，可以解决跨域访问问题与其他模拟后端请求问题;<br>14.<a href="https://www.v2ex.com/" target="_blank" rel="external">V2EX</a>，这是技术解决方案的讨论平台;<br>15.<a href="https://stackoverflow.com/" target="_blank" rel="external">Stack Overflow</a>，在线技术交流平台;<br>16.<a href="http://jsbin.com/" target="_blank" rel="external">jsbin</a>，在线JS代码编写调试工具;<br>17.<a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="external">Mongodb</a>，数据库教程;<br>18.<a href="http://echarts.baidu.com/" target="_blank" rel="external">Echart</a>，百度推出的数据可视化库;<br>19.<a href="http://www.ourd3js.com/wordpress/396/" target="_blank" rel="external">D3.js</a>另一种功能强大的数据可视化库;<br><strong>基于原生体系的开发技术</strong><br>1.<a href="http://fis.baidu.com/" target="_blank" rel="external">FIS</a>，百度推出的前端调试服务器;<br>2.<a href="http://www.jq22.com" target="_blank" rel="external">JQ与bootstrap常用效果库</a>;<br>3.<a href="http://layoutit.justjavac.com/" target="_blank" rel="external">Bootstrap可视化布局</a>,在线进行页面布局，生成相应bootstrap代码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/JS-ES6-实践记录-三/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VKYH">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="VKYH-2017-8-17">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/JS-ES6-实践记录-三/" itemprop="url">JS(ES6)实践记录(三)</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T12:09:40+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章将记录JavaScript ES6下函数相关内容，在ES6中，函数特性大幅度更新，使得JS编程更加灵活。<br><strong>1.ES6中默认参数</strong><br>在ES6中，JS简化了为形参提供默认值的过程，如果没有参数传入值则为其提供一个初始值。示例如下：</p>
<blockquote>
<p>**function makerequest(url,timeout=2000,callback=functio(){}){<br>    //函数其余部分<br>}</p>
</blockquote>
<p>**<br>&gt;<br>其中，url为必须参数，其余两个参数为默认参数.对于函数默认参数而言，个数没有限定。在ES6中，如果一个函数使用了默认参数值，则无论是否显式定义了严格模式，arguments对象行为与ES5严格模式保持一致。默认参数值存在使得arguments对象保持与命名参数分离，默认参数在函数中的变化不会导致arguments对象改变。比如:</p>
<blockquote>
<p>**function mixArgs(first,second=”b”){<br>    console.log(arguments.length);//1<br>    console.log(first===arguments[0]);//true<br>    console.log(second===arguments[1]);//false</p>
</blockquote>
<pre><code>first=&quot;c&quot;;
secod=&quot;d&quot;;
console.log(first===arguments[0]);//false
console.log(second===arguments[1]);//false
</code></pre><p>}</p>
<p>mixArgs(“a”)<br>**<br>&gt;</p>
<p>此例子在ES6中，只给mixArgs传入了一个参数字符串a，因此arguments元素构成的数组只有一个元素字符串a，故其长度为1，且会一直为初始值，不会受函数内部变量变化影响。<br>对于默认参数表达式而言，函数可以通过非原始传参从而得到默认参数的值，示例如下：</p>
<blockquote>
<p>**let value=”5”;</p>
</blockquote>
<p>function getvalue(){<br>    return value++;<br>}<br>function add(first,second=getvalue()){<br>    return first+second;<br>}<br>console.log(add(1,1));//2<br>console.log(add(1));//6<br>console.log(add(1));//7<br>**<br>&gt;<br>在此示例中，初次解析函数声明时不会调用getvalue（）方法，只有当调用add()方法并传入第二个参数时才会调用。变量value初始值为5，每次调用getvalue()方法时加1.第一次调用add(1)，只传入一个参数，没有传入第二个参数，所以执行函数getvalue，使得second默认值变为5，之后代入到函数add()中执行得到6，后面在执行add（1）与之同理。在执行add(1,1)时，直接执行逻辑“1+1”即可返回2.由此观之在没有传入具体参数赋予默认参数时，函数执行过程中任何时候都可以改变其值。<br>除了上面函数传值外，还有一种是固定参数与默认参数之间传值，比如:</p>
<blockquote>
<p>**function getvalue(value){<br>    return value+5;<br>}</p>
</blockquote>
<p>function add(first,second=getvalue(first)){<br>    return first+second;<br>}<br>console.log(add(1,1));//2<br>console.log(add(1));//7<br>**<br>&gt;</p>
<p>在这个示例中，声明second=getvalue(first),所以尽管add(1,1)返回是2，但在执行默认参数为变量的函数值时，执行add(1)返回(1+6)即为7.除此外，还要注意。在引用默认参数时，只允许后面的参数引用前面参数的值，即先定义的参数不能访问后面的参数值，否则会抛出错误。<br><strong>2.ES6中不定参数</strong><br>在函数命名前加三个点（…）就表明这是一个不定参数，该参数为一个数组，包含着自它之后传入的所有参数，通过这个数组名即可逐一访问里面的参数。代码示例如下：</p>
<blockquote>
<p>**function pick(object,…keys){<br>    let result = object.create(null);</p>
</blockquote>
<pre><code>for (let i=0,len=keys.length;i&lt;len;i++){
    result[keys[i]] = object[keys[i]];
}
return result;
</code></pre><p>}</p>
<p>**<br>&gt;</p>
<p>在这个示例中，不定参数keys包含的是object之后传入的所有参数，除此外需要注意每个函数最多只能声明一个不定参数而且一定要包含在末尾。注意，函数的length属性统计的是函数命名参数数量，不定参数的加入不会影响length属性的值。在本示例中，只会pick()函数length值为1，因为只会计算object。<br><strong>3.展开运算符</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="VKYH" />
          <p class="site-author-name" itemprop="name">VKYH</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VKYH</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  










  





  

  

  

  

  

  

</body>
</html>
